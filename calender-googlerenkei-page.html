<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>スケジュール管理（登録ナビ + カレンダー全文表示）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --bg:#f7f7fa; --card:#fff; --line:#e5e7eb; --text:#111827; --muted:#6b7280; --accent:#111827; }
  * { box-sizing:border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif; }
  header { position:sticky; top:0; z-index:20; background:#fff; border-bottom:1px solid var(--line); padding:10px 14px; display:flex; align-items:center; justify-content:space-between; gap:10px; }
  header h1 { margin:0; font-size:18px; }
  .auth { display:flex; align-items:center; gap:8px; }
  button { border:1px solid var(--line); background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font:inherit; }
  button.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
  .hidden { display:none !important; }
  .tabbar { display:flex; gap:8px; }
  .tabbar button.active { background:#0f172a; color:#fff; border-color:#0f172a; }

  /* ===== Views ===== */
  .view { padding:16px; max-width:1000px; margin:16px auto; }
  .card { background:#fff; border:1px solid var(--line); border-radius:14px; box-shadow:0 8px 20px rgba(0,0,0,.04); }
  .head { padding:12px 14px; border-bottom:1px solid var(--line); display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .body { padding:14px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .grow { flex:1 1 auto; }
  .pill { font-size:12px; padding:.2rem .6rem; background:#eef2f7; border-radius:999px; }
  .muted { color:var(--muted); }
  .textarea { width:100%; min-height:280px; padding:12px; border:1px solid var(--line); border-radius:10px; resize:vertical; font:inherit; }
  .nav-arrows button { width:40px; }

  /* カレンダー（全画面） */
  #calendarView { width:100%; max-width:none; margin:0; padding:0; }
  .calendar-shell { height: calc(100vh - 60px); display:flex; flex-direction:column; }
  .cal-toolbar { background:#fff; border-bottom:1px solid var(--line); padding:10px 14px; display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .cal-main { flex:1 1 auto; padding:12px; display:flex; flex-direction:column; min-height:0; }
  .cal-dows { display:grid; grid-template-columns:repeat(7,1fr); gap:8px; margin-bottom:8px; }
  .cal-dow { text-align:center; font-size:12px; color:var(--muted); }
  .cal-grid { display:grid; grid-template-columns:repeat(7,1fr); gap:8px; flex:1 1 auto; min-height:0; }
  .day { background:#fff; border:1px solid var(--line); border-radius:12px; padding:6px; display:flex; flex-direction:column; gap:6px; min-height:100px; }
  .day.inactive { opacity:.5; }
  .day header { display:flex; justify-content:space-between; align-items:center; }
  .num { font-size:14px; }
  .dot { width:8px; height:8px; border-radius:50%; background:#111827; display:inline-block; }
  .todayMark { border-color:#111827; box-shadow:0 0 0 2px rgba(0,0,0,.05) inset; }
  .preview { font-size:12px; color:#334155; white-space:pre-wrap; overflow:hidden; display:-webkit-box; -webkit-box-orient:vertical; -webkit-line-clamp:5; }
  .day .actions { margin-top:auto; display:flex; justify-content:flex-end; }
  .day .actions .open { font-size:12px; }

  /* 月の予定一覧（カレンダー下・全文） */
  .month-list { margin-top:12px; background:#fff; border:1px solid var(--line); border-radius:12px; padding:10px; max-height:28vh; overflow:auto; }
  .month-item { border-bottom:1px dashed var(--line); padding:8px 0; }
  .month-item:last-child { border-bottom:none; }
  .month-item .date { font-weight:700; margin-right:8px; }
  .month-empty { color:var(--muted); padding:8px 0; }

  /* モーダル */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.36); display:flex; align-items:center; justify-content:center; padding:16px; z-index:50; }
  .modal { width:min(840px, 100%); background:#fff; border-radius:14px; border:1px solid var(--line); box-shadow:0 10px 30px rgba(0,0,0,.18); }
  .modal .head { border-bottom:1px solid var(--line); }
  .modal .footer { display:flex; justify-content:flex-end; gap:8px; padding:12px 14px; border-top:1px solid var(--line); }
</style>
</head>
<body>
<header>
  <h1>スケジュール管理</h1>
  <div class="tabbar">
    <button id="tab-register" class="active">登録</button>
    <button id="tab-calendar">カレンダー</button>
  </div>
  <div class="auth">
    <span id="user-info" class="muted">ログイン状態を確認中...</span>
  </div>
</header>

<!-- ===== 登録ビュー（初期表示のみ見せる） ===== -->
<section id="registerView" class="view">
  <div class="card">
    <div class="head">
      <div class="row grow">
        <span class="pill">日付とテンプレを選んで登録</span>

        <div class="row nav-arrows">
          <button id="prevDayBtn" title="前日">◀</button>
          <input id="datePicker" type="date" />
          <button id="nextDayBtn" title="翌日">▶</button>
        </div>

        <select id="preset">
          <option value="tired">仕事終わり（疲れている）</option>
          <option value="energetic">仕事終わり（元気）</option>
          <option value="holiday">休日</option>
          <option value="blank">（空から書く）</option>
        </select>
        <button id="insertPresetBtn">テンプレ挿入</button>
        <button id="todayBtn">今日</button>
      </div>
      <div class="row">
        <button id="saveBtn" class="primary">保存</button>
      </div>
    </div>
    <div class="body">
      <textarea id="scheduleText" class="textarea" placeholder="この日の予定をテキストで自由に書いてください"></textarea>
      <div class="row" style="justify-content:space-between; margin-top:10px;">
        <span id="updatedAt" class="muted">保存日時: —</span>
      </div>
    </div>
  </div>
</section>

<!-- ===== カレンダービュー（全画面） ===== -->
<section id="calendarView" class="view hidden" style="max-width:none;">
  <div class="calendar-shell">
    <div class="cal-toolbar">
      <div class="row">
        <button id="prevMonthBtn">◀ 前月</button>
        <strong id="monthLabel"></strong>
        <button id="nextMonthBtn">次月 ▶</button>
      </div>
      <div class="row">
        <button id="backToRegister">登録画面に戻る</button>
      </div>
    </div>

    <div class="cal-main">
      <div class="cal-dows">
        <div class="cal-dow">日</div><div class="cal-dow">月</div><div class="cal-dow">火</div>
        <div class="cal-dow">水</div><div class="cal-dow">木</div><div class="cal-dow">金</div><div class="cal-dow">土</div>
      </div>

      <div id="calendar" class="cal-grid"></div>

      <!-- 月の予定一覧（クリック無しで全文が見える） -->
      <div id="monthList" class="month-list"></div>
    </div>
  </div>
</section>

<!-- ===== カレンダー用モーダル ===== -->
<div id="modalRoot" class="hidden"></div>

<!-- ===== Firebase SDK v10.12.2 ===== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getFirestore, doc, setDoc, getDoc, getDocs, collection, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  // === あなたの設定（提示いただいたもの） ===
  const firebaseConfig = {
    apiKey: "AIzaSyDuNluIfeulzr_hCr7bHtnCxE1cBneB4kM",
    authDomain: "masu-memo.firebaseapp.com",
    projectId: "masu-memo",
    storageBucket: "masu-memo.appspot.com",
    messagingSenderId: "1065347011702",
    appId: "1:1065347011702:web:e417d565f28d000da83b57"
  };
  const app = initializeApp(firebaseConfig);
  const auth = getAuth();
  const db = getFirestore();
  const provider = new GoogleAuthProvider();

  // ===== DOM =====
  const userInfo = document.getElementById('user-info');
  const tabRegister = document.getElementById('tab-register');
  const tabCalendar = document.getElementById('tab-calendar');
  const registerView = document.getElementById('registerView');
  const calendarView = document.getElementById('calendarView');
  const modalRoot = document.getElementById('modalRoot');

  // 登録ビュー
  const datePicker = document.getElementById('datePicker');
  const prevDayBtn = document.getElementById('prevDayBtn');
  const nextDayBtn = document.getElementById('nextDayBtn');
  const presetSel = document.getElementById('preset');
  const insertPresetBtn = document.getElementById('insertPresetBtn');
  const todayBtn = document.getElementById('todayBtn');
  const scheduleText = document.getElementById('scheduleText');
  const updatedAtEl = document.getElementById('updatedAt');
  const saveBtn = document.getElementById('saveBtn');

  // カレンダー
  const prevMonthBtn = document.getElementById('prevMonthBtn');
  const nextMonthBtn = document.getElementById('nextMonthBtn');
  const backToRegister = document.getElementById('backToRegister');
  const monthLabel = document.getElementById('monthLabel');
  const calGrid = document.getElementById('calendar');
  const monthList = document.getElementById('monthList');

  // ===== Utils =====
  const pad2 = n => String(n).padStart(2,'0');
  const toDateKey = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  const fromDateInput = v => { const [y,m,d] = v.split('-').map(Number); return new Date(y, m-1, d); };
  const today = () => { const n=new Date(); return new Date(n.getFullYear(), n.getMonth(), n.getDate()); };
  const toHuman = dt => dt.toLocaleString('ja-JP', { dateStyle:'medium', timeStyle:'short' });
  const addDays = (d, n) => new Date(d.getFullYear(), d.getMonth(), d.getDate()+n);

  // 登録テンプレ
  const PRESET = {
    tired: `18:00 帰宅＆休憩
18:30 軽めの夕食
19:00 お風呂
20:00 リラックス（テレビ・YouTubeなど）
21:30 就寝準備
22:00 就寝`,
    energetic: `18:00 帰宅
18:30 夕食
19:00 趣味の時間（制作・勉強）
20:30 軽い運動（ジョグ/筋トレ）
21:00 お風呂
22:30 就寝`,
    holiday: `08:00 起床
09:00 おでかけ / 趣味
12:00 昼食
13:00 自由時間（映画・買い物）
18:00 夕食
19:00 お風呂
22:00 就寝`,
    blank: ``
  };

  // 状態
  let currentDate = today();
  let currentMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);

  function setDatePicker(date){ datePicker.value = `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`; }

  // ===== 認証 =====
  async function signInWithGoogle(){ try{ await signInWithPopup(auth, provider); } catch(e){ alert('Googleログインに失敗しました: '+e.message); } }
  async function signOutUser(){ try{ await signOut(auth); } catch(e){ console.error(e);} }
  window.signInWithGoogle = signInWithGoogle; // 互換
  window.signOutUser = signOutUser;

  onAuthStateChanged(auth, async user=>{
    if(user){
      userInfo.innerHTML = `こんにちは、${user.displayName || user.email} さん <button onclick="signOutUser()">ログアウト</button>`;
      showRegister();
      currentDate = today();
      currentMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      setDatePicker(currentDate);
      await refreshEditor(user.uid);
    }else{
      userInfo.innerHTML = `<button onclick="signInWithGoogle()">Googleでログイン</button>`;
      registerView.classList.add('hidden');
      calendarView.classList.add('hidden');
    }
  });

  // ===== Firestore I/O =====
  async function loadSchedule(uid, dateKey){
    const ref = doc(db, 'users', uid, 'schedules', dateKey);
    const snap = await getDoc(ref);
    if(snap.exists()){
      const d = snap.data();
      return { text: d.text || '', updatedAt: d.updatedAt?.toDate?.() || null };
    }
    return { text:'', updatedAt:null };
  }
  async function saveSchedule(uid, dateKey, text){
    const ref = doc(db, 'users', uid, 'schedules', dateKey);
    await setDoc(ref, { text, updatedAt:new Date() }, { merge:true });
  }

  // 当月の全予定（全文）を返す：{ "YYYY-MM-DD": {text, updatedAt} }
  async function getMonthSchedules(uid, y, mIdx){
    const colRef = collection(db, 'users', uid, 'schedules');
    const snaps = await getDocs(colRef);
    const out = {};
    const start = new Date(y, mIdx, 1);
    const end   = new Date(y, mIdx+1, 1);
    snaps.forEach(s=>{
      const id = s.id;
      const m = id.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if(!m) return;
      const d = new Date(+m[1], +m[2]-1, +m[3]);
      if(d>=start && d<end){
        const data = s.data();
        const text = String(data?.text || '').trim();
        if(text){
          out[id] = { text, updatedAt: data.updatedAt?.toDate?.() || null };
        }
      }
    });
    return out;
  }

  // ===== 登録ビュー =====
  async function refreshEditor(uid){
    const { text, updatedAt } = await loadSchedule(uid, toDateKey(currentDate));
    scheduleText.value = text || '';
    updatedAtEl.textContent = updatedAt ? `保存日時: ${toHuman(updatedAt)}` : '保存日時: —';
  }

  insertPresetBtn.addEventListener('click', ()=>{
    const p = PRESET[presetSel.value] ?? '';
    if(scheduleText.value.trim()){
      scheduleText.value = (scheduleText.value + '\n\n' + p).trim();
    }else{
      scheduleText.value = p;
    }
  });

  datePicker.addEventListener('change', async ()=>{
    currentDate = fromDateInput(datePicker.value);
    const u = auth.currentUser; if(u) await refreshEditor(u.uid);
  });

  todayBtn.addEventListener('click', async ()=>{
    currentDate = today();
    setDatePicker(currentDate);
    const u = auth.currentUser; if(u) await refreshEditor(u.uid);
  });

  // ◀ ▶ で日付移動
  async function shiftDay(n){
    currentDate = addDays(currentDate, n);
    setDatePicker(currentDate);
    const u = auth.currentUser; if(u) await refreshEditor(u.uid);
  }
  prevDayBtn.addEventListener('click', ()=> shiftDay(-1));
  nextDayBtn.addEventListener('click', ()=> shiftDay(+1));

  saveBtn.addEventListener('click', async ()=>{
    const u = auth.currentUser; if(!u) return alert('ログインしてください');
    saveBtn.disabled = true;
    try{
      await saveSchedule(u.uid, toDateKey(currentDate), scheduleText.value.trim());
      await refreshEditor(u.uid);
    }catch(e){ alert('保存に失敗しました: '+e.message); }
    finally{ saveBtn.disabled = false; }
  });

  // ===== カレンダービュー =====
  async function buildCalendar(uid){
    const y = currentMonth.getFullYear();
    const m = currentMonth.getMonth();
    monthLabel.textContent = `${y}年 ${m+1}月`;
    calGrid.innerHTML = '';
    monthList.innerHTML = '';

    const firstDay = new Date(y, m, 1).getDay();
    const daysInMonth = new Date(y, m+1, 0).getDate();
    const prevMonthDays = new Date(y, m, 0).getDate();

    const monthData = await getMonthSchedules(uid, y, m); // {dateKey:{text,updatedAt}}

    const totalCells = 42;
    for(let i=0;i<totalCells;i++){
      const cell = document.createElement('div');
      cell.className = 'day';

      const dayNum = i - firstDay + 1;
      let cellDate, inactive=false;

      if(i < firstDay){
        cellDate = new Date(y, m-1, prevMonthDays - (firstDay-1-i));
        inactive = true;
      }else if(dayNum > daysInMonth){
        cellDate = new Date(y, m+1, dayNum - daysInMonth);
        inactive = true;
      }else{
        cellDate = new Date(y, m, dayNum);
      }

      if(inactive) cell.classList.add('inactive');
      if(toDateKey(cellDate) === toDateKey(today())) cell.classList.add('todayMark');

      const head = document.createElement('header');
      const num = document.createElement('div'); num.className='num'; num.textContent = cellDate.getDate();
      const mark = document.createElement('div');
      const key = toDateKey(cellDate);

      const data = monthData[key];
      if(data){ const dot = document.createElement('span'); dot.className='dot'; mark.appendChild(dot); }

      head.appendChild(num); head.appendChild(mark);
      cell.appendChild(head);

      // 予定テキストをそのままセル内に表示（クリック不要で見える）
      if(data){
        const prev = document.createElement('div');
        prev.className = 'preview';
        prev.textContent = data.text; // 全文（見た目は5行にクリップ）
        cell.appendChild(prev);
      }

      // 編集したいときだけ「開く」ボタン
      const actions = document.createElement('div'); actions.className='actions';
      const btn = document.createElement('button'); btn.className='open'; btn.textContent='開く';
      btn.addEventListener('click', ()=> openDayModal(cellDate));
      actions.appendChild(btn);
      cell.appendChild(actions);

      calGrid.appendChild(cell);
    }

    // 下部に「月の予定一覧」（全文）を出す
    const dates = Object.keys(monthData).sort();
    if(dates.length === 0){
      const empty = document.createElement('div'); empty.className='month-empty'; empty.textContent = 'この月の登録済み予定はありません。';
      monthList.appendChild(empty);
    }else{
      dates.forEach(dk=>{
        const item = document.createElement('div'); item.className='month-item';
        const head = document.createElement('div');
        head.innerHTML = `<span class="date">${dk}</span><span class="muted">${monthData[dk].updatedAt ? '保存: '+toHuman(monthData[dk].updatedAt) : ''}</span>`;
        const body = document.createElement('div'); body.style.whiteSpace='pre-wrap'; body.textContent = monthData[dk].text;
        item.appendChild(head); item.appendChild(body);
        monthList.appendChild(item);
      });
    }
  }

  // モーダル（編集）
  async function openDayModal(dateObj){
    const u = auth.currentUser; if(!u) return alert('ログインしてください');
    const key = toDateKey(dateObj);
    const { text, updatedAt } = await loadSchedule(u.uid, key);

    modalRoot.innerHTML = `
      <div class="modal-backdrop" role="dialog" aria-modal="true">
        <div class="modal">
          <div class="head">
            <div class="row grow"><strong>${key} の予定</strong></div>
            <div class="row"><span class="muted">${updatedAt ? '保存日時: '+toHuman(updatedAt) : '保存日時: —'}</span></div>
          </div>
          <div class="body">
            <textarea id="modalText" class="textarea" style="min-height:260px" placeholder="この日の予定を入力">${text || ''}</textarea>
          </div>
          <div class="footer">
            <button id="modalPresetTired">疲れている</button>
            <button id="modalPresetEnergetic">元気</button>
            <button id="modalPresetHoliday">休日</button>
            <div style="flex:1"></div>
            <button id="modalSave" class="primary">保存</button>
            <button id="modalClose">閉じる</button>
          </div>
        </div>
      </div>
    `;
    modalRoot.classList.remove('hidden');

    const modalText = document.getElementById('modalText');
    document.getElementById('modalPresetTired').onclick = ()=> modalText.value = (modalText.value.trim()? modalText.value+'\n\n':'') + PRESET.tired;
    document.getElementById('modalPresetEnergetic').onclick = ()=> modalText.value = (modalText.value.trim()? modalText.value+'\n\n':'') + PRESET.energetic;
    document.getElementById('modalPresetHoliday').onclick = ()=> modalText.value = (modalText.value.trim()? modalText.value+'\n\n':'') + PRESET.holiday;

    document.getElementById('modalClose').onclick = ()=> { modalRoot.classList.add('hidden'); modalRoot.innerHTML=''; };

    document.getElementById('modalSave').onclick = async ()=>{
      try{
        await saveSchedule(u.uid, key, modalText.value.trim());
        if(toDateKey(currentDate) === key){ await refreshEditor(u.uid); }
        await buildCalendar(u.uid);
        document.getElementById('modalClose').click();
      }catch(e){ alert('保存に失敗しました: '+e.message); }
    };
  }

  // ===== タブ切り替え =====
  function showRegister(){
    tabRegister.classList.add('active');
    tabCalendar.classList.remove('active');
    registerView.classList.remove('hidden');
    calendarView.classList.add('hidden');
  }
  async function showCalendar(){
    const u = auth.currentUser; if(!u) return alert('ログインしてください');
    tabRegister.classList.remove('active');
    tabCalendar.classList.add('active');
    registerView.classList.add('hidden');
    calendarView.classList.remove('hidden');
    await buildCalendar(u.uid);
  }
  tabRegister.addEventListener('click', showRegister);
  tabCalendar.addEventListener('click', showCalendar);
  backToRegister.addEventListener('click', showRegister);

  prevMonthBtn.addEventListener('click', async ()=>{
    const u = auth.currentUser; if(!u) return;
    currentMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth()-1, 1);
    await buildCalendar(u.uid);
  });
  nextMonthBtn.addEventListener('click', async ()=>{
    const u = auth.currentUser; if(!u) return;
    currentMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth()+1, 1);
    await buildCalendar(u.uid);
  });

  // 初期
  currentDate = today();
  setDatePicker(currentDate);
</script>

<!-- Firestore ルール（例）
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId}/schedules/{docId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
-->
</body>
</html>
